mod stmt;

use super::utils;

use crate::rap_debug;
use crate::rustc_infer::infer::TyCtxtInferExt;
use rustc_hir::def_id::DefId;
use rustc_infer::traits::{Obligation, ObligationCause};
use rustc_middle::ty::{self, ParamEnv, Ty, TyCtxt, TyKind};
use rustc_span::{Span, DUMMY_SP};
use rustc_trait_selection::traits::query::evaluate_obligation::InferCtxtExt;
use rustc_type_ir::RegionKind::ReErased;
use std::{
    collections::{HashMap, HashSet},
    rc::Rc,
};
pub use stmt::{ApiCall, Stmt, StmtKind, Var, DUMMY_INPUT_VAR};

pub trait HoldTyCtxt<'tcx> {
    fn tcx(&self) -> TyCtxt<'tcx>;
}

pub trait Context<'tcx>: HoldTyCtxt<'tcx> {
    fn stmts(&self) -> &[Stmt];

    fn add_stmt(&mut self, stmt: Stmt);

    fn lift_mutability(&mut self, var: Var, mutability: ty::Mutability);

    fn var_mutability(&self, var: Var) -> ty::Mutability;

    fn ref_region(&self, var: Var) -> ty::Region<'tcx> {
        self.tcx().lifetimes.re_erased
    }

    fn complexity(&self) -> usize {
        self.stmts().len()
    }

    fn mk_var(&mut self, ty: Ty<'tcx>, is_input: bool) -> Var;

    fn set_var_unavailable_unchecked(&mut self, var: Var);

    fn type_of(&self, var: Var) -> Ty<'tcx>;

    fn add_input_stmt(&mut self, ty: Ty<'tcx>) -> Var {
        let var;

        if let ty::Ref(_, inner_ty, mutability) = ty.kind() {
            match (inner_ty.kind(), mutability) {
                (TyKind::Str, ty::Mutability::Not) => {
                    let new_ty = Ty::new_ref(
                        self.tcx(),
                        self.tcx().lifetimes.re_static,
                        *inner_ty,
                        *mutability,
                    );
                    var = self.mk_var(new_ty, true);
                    self.add_stmt(Stmt::input(var));
                }
                (TyKind::Str, ty::Mutability::Mut) => {
                    // FIXME: &mut str can be generated by input, but this usage is really rere.
                    // For now we just panic and expect it never happens.
                    panic!("&mut str is not supported yet, cause I am lazy");
                }
                _ => {
                    let inner_var = self.add_input_stmt(*inner_ty);
                    var = self.add_ref_stmt(inner_var, *mutability);
                }
            }
        } else {
            var = self.mk_var(ty, true);
            self.add_stmt(Stmt::input(var));
        }
        var
    }

    fn add_call_stmt(&mut self, mut call: ApiCall) -> Var {
        let tcx = self.tcx();
        let fn_sig = utils::fn_sig_without_binders(call.fn_did, tcx);
        let output_ty = fn_sig.output();
        for idx in 0..fn_sig.inputs().len() {
            let arg = call.args[idx];
            let input_ty = fn_sig.inputs()[idx];
            self.set_var_unavailable(arg);
            if arg == DUMMY_INPUT_VAR {
                let var = self.add_input_stmt(input_ty);
                call.args[idx] = var;
                self.set_var_unavailable(var);
            }
        }
        let var = self.mk_var(output_ty, false);
        let stmt = Stmt::call(call, var);
        self.add_stmt(stmt);
        var
    }

    // no need to check input, because all inputs exist, all inputs are not primitive already remove from available set
    fn add_call_stmt_all_exist(&mut self, mut call: ApiCall) -> Var {
        let tcx = self.tcx();
        let fn_sig = utils::fn_sig_without_binders(call.fn_did, tcx);
        let output_ty = fn_sig.output();
        for idx in 0..fn_sig.inputs().len() {
            let arg = call.args[idx];
            let input_ty = fn_sig.inputs()[idx];
            if arg == DUMMY_INPUT_VAR {
                let var = self.add_input_stmt(input_ty);
                call.args[idx] = var;
                self.set_var_unavailable(var);
            }
        }
        let var = self.mk_var(output_ty, false);
        let stmt = Stmt::call(call, var);
        self.add_stmt(stmt);
        var
    }

    fn add_ref_stmt(&mut self, var: Var, mutability: ty::Mutability) -> Var {
        self.lift_mutability(var, mutability);
        self.set_var_unavailable(var);

        let ref_ty = ty::Ty::new_ref(
            self.tcx(),
            self.ref_region(var),
            self.type_of(var),
            mutability,
        );
        let new_var = self.mk_var(ref_ty, false);
        self.add_stmt(Stmt::ref_(new_var, var, mutability));
        new_var
    }

    // if the output_ty of expr does not implement Copy, we need to remove the expr from the available set
    fn set_var_unavailable(&mut self, var: Var) -> bool {
        let tcx = self.tcx();
        if var == DUMMY_INPUT_VAR || !self.available_values().contains(&var) {
            return false;
        }

        let output_ty = self.type_of(var);
        let is_mut_ref =
            output_ty.is_ref() && matches!(output_ty.ref_mutability(), Some(ty::Mutability::Mut));

        if !is_mut_ref && utils::is_ty_impl_copy(output_ty, tcx) {
            return false;
        }

        self.set_var_unavailable_unchecked(var);
        true
    }

    fn available_values(&self) -> &HashSet<Var>;

    fn all_possible_providers(&self, ty: Ty<'tcx>) -> Vec<Var> {
        let mut ret = Vec::new();
        if utils::is_fuzzable_ty(ty, self.tcx()) {
            ret.push(DUMMY_INPUT_VAR);
        }
        for val in self.available_values() {
            if utils::is_ty_eq(ty, self.type_of(*val), self.tcx()) {
                ret.push(val.clone());
            }
        }
        ret
    }

    fn mk_fn_sig(&self, stmt: &Stmt) -> ty::FnSig<'tcx> {
        match stmt.kind() {
            StmtKind::Call(call) => {
                let tcx = self.tcx();
                let fn_sig = utils::fn_sig_without_binders(call.fn_did(), tcx);
                let var_ty = self.type_of(stmt.place());

                // get actual vid of input in the pattern
                let mut inputs = Vec::new();
                for var in call.args() {
                    let ty = self.type_of(*var);
                    inputs.push(ty);
                }
                tcx.mk_fn_sig(
                    inputs.into_iter(),
                    var_ty,
                    fn_sig.c_variadic,
                    fn_sig.safety,
                    fn_sig.abi,
                )
            }
            _ => panic!("not a call"),
        }
    }
}

#[derive(Clone)]
pub struct ContextBase<'tcx> {
    stmts: Vec<Stmt>,
    available: HashSet<Var>,
    var_ty: HashMap<Var, Ty<'tcx>>,
    var_is_mut: HashMap<Var, ty::Mutability>,
    tcx: TyCtxt<'tcx>,
}

impl<'tcx> HoldTyCtxt<'tcx> for ContextBase<'tcx> {
    fn tcx(&self) -> TyCtxt<'tcx> {
        self.tcx
    }
}

impl<'tcx> ContextBase<'tcx> {
    pub fn new(tcx: TyCtxt<'tcx>) -> ContextBase<'tcx> {
        ContextBase {
            stmts: Vec::new(),
            available: HashSet::new(),
            var_ty: HashMap::new(),
            var_is_mut: HashMap::new(),
            tcx,
        }
    }

    pub fn type_of(&self, var: Var) -> Ty<'tcx> {
        *self.var_ty.get(&var).expect("no type for var")
    }
}

impl<'tcx> Context<'tcx> for ContextBase<'tcx> {
    fn stmts(&self) -> &[Stmt] {
        &self.stmts
    }
    fn add_stmt(&mut self, stmt: Stmt) {
        self.stmts.push(stmt);
    }
    fn lift_mutability(&mut self, var: Var, mutability: ty::Mutability) {
        if matches!(mutability, ty::Mutability::Mut) {
            self.var_is_mut.insert(var, ty::Mutability::Mut);
        }
    }

    fn var_mutability(&self, var: Var) -> ty::Mutability {
        *self.var_is_mut.get(&var).unwrap_or(&ty::Mutability::Not)
    }

    fn available_values(&self) -> &HashSet<Var> {
        &self.available
    }

    fn mk_var(&mut self, ty: Ty<'tcx>, is_input: bool) -> Var {
        let next_var = Var(self.var_ty.len(), is_input);
        self.var_ty.insert(next_var, ty);
        self.available.insert(next_var);
        next_var
    }

    fn set_var_unavailable_unchecked(&mut self, var: Var) {
        self.available.remove(&var);
    }

    fn type_of(&self, var: Var) -> Ty<'tcx> {
        self.var_ty[&var]
    }
}
