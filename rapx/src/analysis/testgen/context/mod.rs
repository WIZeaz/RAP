mod stmt;

use super::utils::{self, is_fuzzable_ty};

use crate::rap_debug;
use crate::rustc_infer::infer::TyCtxtInferExt;
use rustc_hir::def_id::DefId;
use rustc_infer::traits::{Obligation, ObligationCause};
use rustc_middle::ty::{self, ParamEnv, Ty, TyCtxt, TyKind};
use rustc_span::{Span, DUMMY_SP};
use rustc_trait_selection::traits::query::evaluate_obligation::InferCtxtExt;
use rustc_type_ir::RegionKind::ReErased;
use std::{
    collections::{HashMap, HashSet},
    env::var,
    rc::Rc,
};
pub use stmt::{ApiCall, Stmt, StmtKind, Var, DUMMY_INPUT_VAR};

pub trait HoldTyCtxt<'tcx> {
    fn tcx(&self) -> TyCtxt<'tcx>;
}

pub trait Context<'tcx>: HoldTyCtxt<'tcx> {
    fn stmts(&self) -> &[Stmt];

    fn add_stmt(&mut self, stmt: Stmt);

    fn lift_mutability(&mut self, var: Var, mutability: ty::Mutability);

    fn var_mutability(&self, var: Var) -> ty::Mutability;

    fn ref_region(&self, var: Var) -> ty::Region<'tcx> {
        self.tcx().lifetimes.re_erased
    }

    fn complexity(&self) -> usize {
        self.stmts().len()
    }

    fn mk_var(&mut self, ty: Ty<'tcx>, is_input: bool) -> Var;

    fn set_var_unavailable_unchecked(&mut self, var: Var);

    fn type_of(&self, var: Var) -> Ty<'tcx>;

    fn add_input_stmt(&mut self, ty: Ty<'tcx>) -> Var {
        let var;

        if let ty::Ref(_, inner_ty, mutability) = ty.kind() {
            match (inner_ty.kind(), mutability) {
                (TyKind::Str, ty::Mutability::Not) => {
                    let new_ty = Ty::new_ref(
                        self.tcx(),
                        self.tcx().lifetimes.re_static,
                        *inner_ty,
                        *mutability,
                    );
                    var = self.mk_var(new_ty, true);
                    self.add_stmt(Stmt::input(var));
                }
                (TyKind::Str, ty::Mutability::Mut) => {
                    // FIXME: &mut str can be generated by input, but this usage is really rere.
                    // For now we just panic and expect it never happens.
                    panic!("&mut str is not supported yet, cause I am lazy");
                }
                _ => {
                    let inner_var = self.add_input_stmt(*inner_ty);
                    var = self.add_ref_stmt(inner_var, *mutability);
                }
            }
        } else {
            var = self.mk_var(ty, true);
            self.add_stmt(Stmt::input(var));
        }
        var
    }

    fn add_call_stmt(&mut self, mut call: ApiCall) -> Var {
        let tcx = self.tcx();
        let fn_sig = utils::fn_sig_without_binders(call.fn_did, tcx);
        let output_ty = fn_sig.output();
        for idx in 0..fn_sig.inputs().len() {
            let arg = call.args[idx];
            let input_ty = fn_sig.inputs()[idx];
            self.set_var_unavailable(arg);
            if arg == DUMMY_INPUT_VAR {
                let var = self.add_input_stmt(input_ty);
                call.args[idx] = var;
                self.set_var_unavailable(var);
            }
        }
        let var = self.mk_var(output_ty, false);
        let stmt = Stmt::call(call, var);
        self.add_stmt(stmt);
        var
    }

    /// no need to check input, because all inputs exist, all inputs that is not primitive already be removed from available set
    fn add_call_stmt_all_exist(&mut self, mut call: ApiCall) -> Var {
        let tcx = self.tcx();
        let fn_sig = utils::fn_sig_without_binders(call.fn_did, tcx);
        let output_ty = fn_sig.output();
        for idx in 0..fn_sig.inputs().len() {
            let arg = call.args[idx];
            let input_ty = fn_sig.inputs()[idx];
            if arg == DUMMY_INPUT_VAR {
                let var = self.add_input_stmt(input_ty);
                call.args[idx] = var;
                self.set_var_unavailable(var);
            }
        }
        let var = self.mk_var(output_ty, false);
        let stmt = Stmt::call(call, var);
        self.add_stmt(stmt);
        var
    }

    fn add_ref_stmt(&mut self, var: Var, mutability: ty::Mutability) -> Var {
        self.lift_mutability(var, mutability);
        self.set_var_unavailable(var);

        let ref_ty = ty::Ty::new_ref(
            self.tcx(),
            self.ref_region(var),
            self.type_of(var),
            mutability,
        );
        let new_var = self.mk_var(ref_ty, false);
        self.add_stmt(Stmt::ref_(new_var, var, mutability));
        new_var
    }

    // if the output_ty of expr does not implement Copy, we need to remove the expr from the available set
    fn set_var_unavailable(&mut self, var: Var) -> bool {
        let tcx = self.tcx();
        if var == DUMMY_INPUT_VAR || !self.available_values().contains(&var) {
            return false;
        }

        let output_ty = self.type_of(var);
        let is_mut_ref =
            output_ty.is_ref() && matches!(output_ty.ref_mutability(), Some(ty::Mutability::Mut));

        if !is_mut_ref && utils::is_ty_impl_copy(output_ty, tcx) {
            return false;
        }

        self.set_var_unavailable_unchecked(var);
        true
    }

    fn available_values(&self) -> &HashSet<Var>;

    fn all_possible_providers(&self, ty: Ty<'tcx>) -> Vec<Var> {
        let mut ret = Vec::new();
        if utils::is_fuzzable_ty(ty, self.tcx()) {
            ret.push(DUMMY_INPUT_VAR);
        }
        for val in self.available_values() {
            if utils::is_ty_eq(ty, self.type_of(*val), self.tcx()) {
                ret.push(val.clone());
            }
        }
        ret
    }

    fn mk_fn_sig(&self, stmt: &Stmt) -> ty::FnSig<'tcx> {
        match stmt.kind() {
            StmtKind::Call(call) => {
                let tcx = self.tcx();
                let fn_sig = utils::fn_sig_without_binders(call.fn_did(), tcx);
                let var_ty = self.type_of(stmt.place());

                // get actual vid of input in the pattern
                let mut inputs = Vec::new();
                for var in call.args() {
                    let ty = self.type_of(*var);
                    inputs.push(ty);
                }
                tcx.mk_fn_sig(
                    inputs.into_iter(),
                    var_ty,
                    fn_sig.c_variadic,
                    fn_sig.safety,
                    fn_sig.abi,
                )
            }
            _ => panic!("not a call"),
        }
    }
}

#[derive(Clone)]
pub struct ContextBase<'tcx> {
    stmts: Vec<Stmt>,
    available: HashSet<Var>,
    var_ty: HashMap<Var, Ty<'tcx>>,
    var_is_mut: HashMap<Var, ty::Mutability>,
    var_references: HashMap<Var, HashSet<Var>>, // records: T -> {&T, &mut T}
    provider_cache: HashMap<Ty<'tcx>, Vec<Var>>, // records: T -> {var1, var2, ...}
    tcx: TyCtxt<'tcx>,
}

impl<'tcx> HoldTyCtxt<'tcx> for ContextBase<'tcx> {
    fn tcx(&self) -> TyCtxt<'tcx> {
        self.tcx
    }
}

impl<'tcx> ContextBase<'tcx> {
    pub fn new(tcx: TyCtxt<'tcx>) -> ContextBase<'tcx> {
        ContextBase {
            stmts: Vec::new(),
            available: HashSet::new(),
            var_ty: HashMap::new(),
            var_is_mut: HashMap::new(),
            var_references: HashMap::new(),
            provider_cache: HashMap::new(),
            tcx,
        }
    }

    pub fn type_of(&self, var: Var) -> Ty<'tcx> {
        *self.var_ty.get(&var).expect("no type for var: {var:?}")
    }

    fn update_provider_cache(&mut self, var: Var, ty: Ty<'tcx>, add: bool) {
        if add {
            self.provider_cache
                .entry(ty)
                .or_insert_with(Vec::new)
                .push(var);
        } else {
            if let Some(providers) = self.provider_cache.get_mut(&ty) {
                providers.retain(|v| *v != var);
            }
        }
    }

    /// add mut-version when need to add reference
    pub fn all_possible_providers_mut(&mut self, ty: Ty<'tcx>) -> Vec<Var> {
        let mut ret = Vec::new();
        if is_fuzzable_ty(ty, self.tcx()) {
            ret.push(DUMMY_INPUT_VAR);
        }
        if let ty::Ref(_, inner_ty, mutability) = ty.kind() {
            // find all possible providers for ty
            if let Some(providers) = self.provider_cache.get(&ty) {
                ret.extend(providers.iter().copied());
            }
            // find T values that can be converted to &T or &mut T
            if ret.is_empty() {
                let produce_ref_vars: Vec<Var> = self
                    .all_possible_providers_mut(*inner_ty)
                    .iter()
                    .filter(|v| {
                        let inner_mutability = self.var_mutability(**v);
                        if inner_mutability == *mutability {
                            return true;
                        }
                        false
                    })
                    .copied()
                    .collect();
                if !produce_ref_vars.is_empty() {
                    let ref_var = self.add_ref_stmt(produce_ref_vars[0], *mutability);
                    ret.push(ref_var);
                }
            }
        } else {
            if let Some(providers) = self.provider_cache.get(&ty) {
                ret.extend(providers.iter().copied());
            }
        }
        ret
    }
}

impl<'tcx> Context<'tcx> for ContextBase<'tcx> {
    fn stmts(&self) -> &[Stmt] {
        &self.stmts
    }
    fn add_stmt(&mut self, stmt: Stmt) {
        self.stmts.push(stmt);
    }
    fn lift_mutability(&mut self, var: Var, mutability: ty::Mutability) {
        if matches!(mutability, ty::Mutability::Mut) {
            self.var_is_mut.insert(var, ty::Mutability::Mut);
        }
    }

    fn var_mutability(&self, var: Var) -> ty::Mutability {
        *self.var_is_mut.get(&var).unwrap_or(&ty::Mutability::Not)
    }

    fn available_values(&self) -> &HashSet<Var> {
        &self.available
    }

    fn mk_var(&mut self, ty: Ty<'tcx>, is_input: bool) -> Var {
        let next_var = Var(self.var_ty.len() + 1, is_input);
        self.var_ty.insert(next_var, ty);
        self.available.insert(next_var);
        self.update_provider_cache(next_var, ty, true);
        next_var
    }

    /// refactor this function to modify var_references
    fn set_var_unavailable_unchecked(&mut self, var: Var) {
        self.available.remove(&var);
        if let Some(ty) = self.var_ty.get(&var) {
            self.update_provider_cache(var, *ty, false);
        }
        // remove all references to this var
        if let Some(refs) = self.var_references.remove(&var) {
            for ref_var in refs {
                self.set_var_unavailable_unchecked(ref_var);
            }
        }
    }

    fn type_of(&self, var: Var) -> Ty<'tcx> {
        self.var_ty[&var]
    }

    /// refactor this function to use var_references
    fn add_ref_stmt(&mut self, var: Var, mutability: ty::Mutability) -> Var {
        self.lift_mutability(var, mutability);
        let ref_ty = ty::Ty::new_ref(
            self.tcx(),
            self.ref_region(var),
            self.type_of(var),
            mutability,
        );

        let new_var = self.mk_var(ref_ty, false);
        self.var_references
            .entry(var)
            .or_insert_with(HashSet::new)
            .insert(new_var);
        self.add_stmt(Stmt::ref_(new_var, var, mutability));
        new_var
    }
}
